
## 아이템 13 - clone 재정의는 주의해서 진행하라 - 핵심 정리
---

### clone 규약

clone 메서드는 Object 에 정의되어있는 메서드이다.

```java
public interface Cloneable {
}
```
아무것도 정의되어 있지 않은 ``Cloneable`` 인터페이스가 존재한다.

clone 메서드를 구현하려면 ``Cloneable`` 인터페이스를 ``implements`` 해야한다.

``Cloneable`` 인터페이스를 ``implements`` 하지 않으면 __clone 메서드__ 는 동작하지 않는다.

오브젝트에 정의되어있는 clone 메서드 기능을 제공하기 위해서는 

- ``Cloneable`` 인터페이스를 ``implements`` 한다.
- __clone 메서드__ 를 오버라이딩한다. (이때 super.clone() 메서드를 사용해야 한다.)

__clone 메서드__ 를 재정의 하기위해서는 몇가지 규약을 지켜야한다.

```java
x.clone() != x // 반드시 true
```
클론을 한 객체는 반드시 원본과는 다른 객체여야한다.

주소연산자로 비교했을 때 다른 객체라는 결과가 나와야한다.

즉, 레퍼런스 자체가 다른 오브젝트여야 한다.

```java
x.clone().getClass() == x.getClass() // 반드시 true
```
클론을 했던 클래스와 원본 클래스는 __동일한 클래스__ 여야한다.

``getClass()`` 로 비교했을 때 같다는 결과가 나와야한다.

```java
x.clone().equals(x) // true 가 아닐수도 있다.
```
equals 로 비교했을 때 같을수도 있고, 다를 수도 있다.

복사를 했다 하더라도 그 객체를 식별하는 유일한 값들이 달라져야하는 경우가 있다.

복사를 하는 과정 중에 __clone() 메서드 내부__ 에서 달라져야하는 필드값은 새로 설정해야하는 경우가 있다.

때문에 반드시 equals 는 true 가 아니어도 된다.

```java
public final class PhoneNumber implements Cloneable {
   private final short areaCode, prefix, lineNum;

   public PhoneNumber(int areaCode, int prefix, int lineNum) {
      this.areaCode = rangeCheck(areaCode, 999, "지역코드");
      this.prefix   = rangeCheck(prefix,   999, "프리픽스");
      this.lineNum  = rangeCheck(lineNum, 9999, "가입자 번호");
      System.out.println("constructor is called");
   }

   private static short rangeCheck(int val, int max, String arg) {
      if (val < 0 || val > max)
         throw new IllegalArgumentException(arg + ": " + val);
      return (short) val;
   }

   // 코드 13-1 가변 상태를 참조하지 않는 클래스용 clone 메서드 (79쪽)
   @Override
   public PhoneNumber clone() {
      try {
         return (PhoneNumber) super.clone();
      } catch (CloneNotSupportedException e) {
         throw new AssertionError();  // 일어날 수 없는 일이다.
      }
   }

   @Override public boolean equals(Object o) {
      if (o == this)
         return true;
      if (!(o instanceof PhoneNumber))
         return false;
      PhoneNumber pn = (PhoneNumber)o;
      return pn.lineNum == lineNum && pn.prefix == prefix
            && pn.areaCode == areaCode;
   }

   @Override public int hashCode() {
      int result = Short.hashCode(areaCode);
      result = 31 * result + Short.hashCode(prefix);
      result = 31 * result + Short.hashCode(lineNum);
      return result;
   }
   
   @Override public String toString() {
      return String.format("%03d-%03d-%04d",
            areaCode, prefix, lineNum);
   }
}
```

clone 메서드를 재정의한 PhoneNumber 클래스를 작성한다.

```java
public class main {
   public static void main(String[] args) {
      PhoneNumber pn = new PhoneNumber(707, 867, 5309);
      Map<PhoneNumber, String> m = new HashMap<>();
      m.put(pn, "제니");
      PhoneNumber clone = pn.clone();
      System.out.println(m.get(clone));

      System.out.println(clone != pn); // 반드시 true
      System.out.println(clone.getClass() == pn.getClass()); // 반드시 true
      System.out.println(clone.equals(pn)); // true가 아닐 수도 있다.
   }
}
```
clone 규약을 어떻게 지키고 있는지 확인하는 코드를 작성한다.

__clone__ 만들어지는 인스턴스는 __생성자를 사용하지 않는다.__

```java
   @Override
   public PhoneNumber clone() {
      try {
         return (PhoneNumber) super.clone();
      } catch (CloneNotSupportedException e) {
         throw new AssertionError();  // 일어날 수 없는 일이다.
      }
   }
```
__clone__  메서드를 재정의 했을 시 최종적으로는 ``super.clone()`` 을 호출하게 된다.

결국 Object에 있는 clone 메서드를 사용한다.

대표적인 __불변 객체__ 에서의 __clone__ 메서드를 구현하는 방법이다.

```java
@Override
protected Object clone() throws CloneNotSupportedException {
      return super.clone();
      }

```
clone() 메서드의 원래 형태이다.

앞서 정의한 clone() 메서드와는 차이가 있다.

```java
   @Override
   public PhoneNumber clone() {
      try {
         return (PhoneNumber) super.clone();
      } catch (CloneNotSupportedException e) {
         throw new AssertionError();  // 일어날 수 없는 일이다.
      }
   }
```

하나하나 살펴보자면 ``protected`` 대신 ``public`` 을 사용했다.

__어떤 클래스를 상속__ 받아서 __오버라이딩__ 을 할 때 __접근지시자__ 는 상위 클래스에 있는 접근지시자와 같거나 넓어야한다.

만약 ``protected`` 를 사용한다면 해당 클래스의 하위 클래스에서만 사용할 수 있게 된다.

보통 clone() 메서드를 사용하는 클라이언트 코드는 해당 클래스 외부에 있는 클래스일 것이다.

자바는 __오버라이딩하는 메서드__ 에서 리턴 타입이 오버라이딩을 해야하는 메서드의 리턴타입의 __하위 타입__ 을 선언해도 __오버라이딩으로 인정__ 해준다.

때문에 원래 리턴타입인 ``Object`` 보다 더 구체적인 타입으로 리턴 타입을 선언할 수 있다.

구체적인 타입으로 리턴하면 clone() 를 사용하는 쪽에서 타입 캐스팅을 해주지 않아도 된다.

``CloneNotSupportedException`` 은 __Checked Exception__ 계열이다.

``CloneNotSupportedException`` 이 발생했을 때 딱히 해줄 일이 없기 때문에 다른 오류를 던지도록 작성한다.

그렇게 해서 

```java
   @Override
   public PhoneNumber clone() {
      try {
         return (PhoneNumber) super.clone();
      } catch (CloneNotSupportedException e) {
         throw new AssertionError();  // 일어날 수 없는 일이다.
      }
   }
```
위와 같은 코드를 작성하게 된다.

주의할 점은 ``super.clone()`` 을 꼭 사용해야한다는 점이다.

임의대로 ``super.clone()`` 을 사용하지 않고 생성자를 사용해서는 안된다.

```java
public class Item implements Cloneable {

   private String name;

   /**
    * 이렇게 구현하면 하위 클래스의 clone()이 깨질 수 있다. p78
    * @return
    */
   @Override
   public Item clone() {
      Item item = new Item();
      item.name = this.name;
      return item;
   }
}
```

``super.clone()`` 을 사용하지 않고 생성자를 사용하는 Item 클래스를 작성한다.

```java
public class SubItem extends Item implements Cloneable {

   private String name;

   @Override
   public SubItem clone() {
      return (SubItem)super.clone();
   }

   public static void main(String[] args) {
      SubItem item = new SubItem();
      SubItem clone = item.clone();

      System.out.println(clone != item);
      System.out.println(clone.getClass() == item.getClass());
      System.out.println(clone.equals(item));
   }
}
```

Item 클래스를 상속받은 SubItem 클래스를 생성한다.

위의 코드에서는 clone() 를 호출하면서 에러가 발생한다.

구체적인 타입은 상위타입으로 변환이 되지만 상위 타입은 구체적인 타입으로 변환이 안되기 떄문이다.

```java
public class SubItem extends Item implements Cloneable {

   private String name;

//   @Override
//   public SubItem clone() {
//      return (SubItem)super.clone();
//   }

   public static void main(String[] args) {
      SubItem item = new SubItem();
      SubItem clone = (SubItem) item.clone();

      System.out.println(clone != item);
      System.out.println(clone.getClass() == item.getClass());
      System.out.println(clone.equals(item));
   }
}
```
SubItem 클래스에서 clone 메서드를 재정의 하지 않았다.

하지만 역시나 casting 에러가 발생한다.

Object 에 암묵적으로 구현되어 있는 clone 메서드가 사용되면서 결국 ``super.clone()`` 이 호출되면서

결국 Item 클래스의 clone 메서드가 호출된다.

```java
   @Override
   public Item clone() {
      Item item = new Item();
      item.name = this.name;
      return item;
   }
```
이렇게 생성자를 사용하면 안된다.

``super.clone()`` 을 통해서 나오는 인스턴스가 __비 결정적__ 이기 때문이다.

```java
@Override
public Item clone() {
      Item result = null;
      try {
         result = (Item) super.clone();
         return result;
      } catch (CloneNotSupportedException e) {
         throw new AssertionError();
      }
 }
```

위처럼 clone 메서드를 작성한다.

``super.clone()`` 호출 시 나오게 되는 인스턴스의 타입은 __하위 타입에서 호출__ 이 되면 __하위 타입__ 으로 나오게 된다.

``super.clone()`` 이 어디서 호출이 되느냐에 따라 실제 반환되는 인스턴스 타입이 달라지게 된다.

때문에 clone 메서드 구현시 __생성자__ 대신 반드시 ``super.clone()`` 을 호출해야 한다.

__불변 객체__ 는 다음의 사항들을 지켜주면 clone 메서드 사용이 가능하다.

- Cloneable 인터페이스를 구현
- clone 메서드를 재정의한다. 이때 super.clone()을 사용해야 한다.

--- 





