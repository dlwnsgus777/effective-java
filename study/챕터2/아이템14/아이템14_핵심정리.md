
## 아이템 14 - Comparable 을 구현할지 고민하라 - 핵심 정리
---

Comparable 은 Object 가 제공하는 메서드는 아니지만 일반적으로 널리 사용할 수 있는 __인터페이스__ 이다.

Comparable 은 __엘리먼트가 지닌 자연적인 순서(natural order)__ 를 정해줄 때 사용하는 인터페이스이다.

Comparable 은 우리가 비교해주고 싶은 순서가 있는 경우에 그 비교 방법을 구현할 수 있다.

Comparable 은 __제네릭 타입__ 을 가지고 있기 때문에 __컴파일 타임__ 에 체크가 가능한 장점이 있다.

``compareTo`` 를 재정의 할때는 몇가지 규약이 있다.

### compareTo 규약

compareTo 메서드는 구현시 __양수, 0 , 음수__ 를 return 해야한다.

내 자신이 넘겸받은 값보다 크다면 __양수__, 넘겨받은 객체와 같다면 __0__ , 작다면 __음수__ 를 return 한다.

```java
public class CompareToConvention {

   public static void main(String[] args) {
      BigDecimal n1 = BigDecimal.valueOf(23134134);
      BigDecimal n2 = BigDecimal.valueOf(11231230);
      BigDecimal n3 = BigDecimal.valueOf(53534552);
      BigDecimal n4 = BigDecimal.valueOf(11231230);

      // p88, 반사성
      System.out.println(n1.compareTo(n1));
   }
}
```
자기자신과 ``compareTo`` 를 했을 때 __같다__ 고 나와야한다.

이걸 반사성이라고 한다.

```java
public class CompareToConvention {

   public static void main(String[] args) {
      BigDecimal n1 = BigDecimal.valueOf(23134134);
      BigDecimal n2 = BigDecimal.valueOf(11231230);
      BigDecimal n3 = BigDecimal.valueOf(53534552);
      BigDecimal n4 = BigDecimal.valueOf(11231230);

      // p88, 대칭성
      System.out.println(n1.compareTo(n2));
      System.out.println(n2.compareTo(n1));
   }
}
```
대칭성을 맞추어 주어야한다.

n1이 n2 보다 크다면 n2 는 n1 보다 작다고 나와야한다.

```java
public class CompareToConvention {

   public static void main(String[] args) {
      BigDecimal n1 = BigDecimal.valueOf(23134134);
      BigDecimal n2 = BigDecimal.valueOf(11231230);
      BigDecimal n3 = BigDecimal.valueOf(53534552);
      BigDecimal n4 = BigDecimal.valueOf(11231230);

      // p89, 추이성
      System.out.println(n3.compareTo(n1) > 0); //true
      System.out.println(n1.compareTo(n2) > 0); //true
      System.out.println(n3.compareTo(n2) > 0); //true
   }
}
```
추이성을 맞추어 주야한다.

n3 이 n1 보다 크고, n1 이 n2 보다 크다면 n3 은 n2 보다 크다는 결과가 나와야한다.

```java
public class CompareToConvention {

   public static void main(String[] args) {
      BigDecimal n1 = BigDecimal.valueOf(23134134);
      BigDecimal n2 = BigDecimal.valueOf(11231230);
      BigDecimal n3 = BigDecimal.valueOf(53534552);
      BigDecimal n4 = BigDecimal.valueOf(11231230);

      // p89, 일관성
      System.out.println(n4.compareTo(n2));
      System.out.println(n2.compareTo(n1));
      System.out.println(n4.compareTo(n1));
   }
}
```
일관성을 맞추어 주어야한다.

만약 어떤 두개의 수가 __같다면__ 다른 어떤 수와 비교해도 결과가 두 수 모두 동일해야한다.

n4 와 n2 가 같다면 n2 와 n1 을 비교한 값과 n4 와 n1 을 비교한 값이 동일해야한다.

```java
public class CompareToConvention {

   public static void main(String[] args) {
      BigDecimal n1 = BigDecimal.valueOf(23134134);
      BigDecimal n2 = BigDecimal.valueOf(11231230);
      BigDecimal n3 = BigDecimal.valueOf(53534552);
      BigDecimal n4 = BigDecimal.valueOf(11231230);

      // p89, compareTo가 0이라면 equals는 true여야 한다. (아닐 수도 있고..)
      BigDecimal oneZero = new BigDecimal("1.0");
      BigDecimal oneZeroZero = new BigDecimal("1.00");
      System.out.println(oneZero.compareTo(oneZeroZero)); // Tree, TreeMap
      System.out.println(oneZero.equals(oneZeroZero)); // 순서가 없는 콜렉션
   }
}
```
compareTo가 0 (같다) 이라면 equals 는 true 여야 한다. 

이 규약은 지키면 좋지만 안지켜질 수도 있다.

TreeSet 이나 TreeMap 에 값을 넣을 때는 compareTo 메서드로 비교해 값이 들어간다.

위의 코드에서 oneZero 와 oneZeroZero 는 compareTo 에서 같다고 나온다.

반면 순서가 없는 컬렉션의 경우에는 equals 를 통해 비교하게 되는데

oneZero 와 oneZeroZero 는 equals 에서 다르다고 나온다.

만약 compareTo 가 같지만 equals 에서는 다르다면 __문서화__ 를 해놓는 것을 권장한다.

---

### compareTo 구현 방법 1.

