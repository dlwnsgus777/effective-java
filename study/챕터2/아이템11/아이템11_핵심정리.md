
## 아이템 11. equals 를 재정의하려거든 hashCode 도 재정의하라 - 핵심 정리
---

__equals 메서드를__ 구현할 때는 반드시 __hashCode__ 도 구현해야한다.

equals 메서드와 hashCode 는 같이 정의되어 있지 않다면 잘못된 코드이다.

hashCode 를 구현할 때는 몇가지 __규약__ 이 존재한다.

 - equals 메서드에서 __사용하는 값이 변경되지 않았다면__ hashCode 는 __몇번이 실행__ 되더라도 __동일한 값__ 을 리턴해야한다.
 - 두 객체를 equals 메서드로 비교했을 때 __같은 객체__ 로 나온다면 두 객체의 hashCode 값도 __같아야 한다.__
 - 성능을 고려해 다른 객체라면 다른 hashCode 를 리턴하는 걸 추천한다. 다른 객체지만 hashCode 가 같아도 __문제는 없지만 성능상 단점이 생긴다.__

여기서 항상 같은 hashCode 를 리턴하게 되면 성능이 ``O(1)`` 에서 ``O(n)`` 으로 떨어지게 된다.

hashCode 구현시에는 __equals 메서드__ 에서 __사용하는 필드들을 모두 사용__ 해서 계산해야한다.

```java
public final class PhoneNumber {
   private final short areaCode, prefix, lineNum;

   public PhoneNumber(int areaCode, int prefix, int lineNum) {
      this.areaCode = rangeCheck(areaCode, 999, "area code");
      this.prefix   = rangeCheck(prefix,   999, "prefix");
      this.lineNum  = rangeCheck(lineNum, 9999, "line num");
   }

   private static short rangeCheck(int val, int max, String arg) {
      if (val < 0 || val > max)
         throw new IllegalArgumentException(arg + ": " + val);
      return (short) val;
   }

   @Override public boolean equals(Object o) {
      if (o == this)
         return true;
      if (!(o instanceof PhoneNumber))
         return false;
      PhoneNumber pn = (PhoneNumber)o;
      return pn.lineNum == lineNum && pn.prefix == prefix
            && pn.areaCode == areaCode;
   }
}
```
PhoneNumber 클래스를 작성한다.

PhoneNumber 클래스는 equals 메서드는 구현되어 있지만 hashCode 는 구현되어 있지 않다.

```java
public class HashMapTest {

   public static void main(String[] args) {
      Map<PhoneNumber, String> map = new HashMap<>();

      PhoneNumber number1 = new PhoneNumber(123, 456, 7890);
      PhoneNumber number2 = new PhoneNumber(123, 456, 7890);

//         TODO 같은 인스턴스인데 다른 hashCode
//         다른 인스턴스인데 같은 hashCode를 쓴다면?
      System.out.println(number1.equals(number2));
      System.out.println(number1.hashCode());
      System.out.println(number2.hashCode());

      map.put(number1, "keesun");
      map.put(number2, "whiteship");

      String s = map.get(number2);
      System.out.println(s);
   }
}
```
위의 코드에서 PhoneNumber 클래스에 같은 번호를 파라미터로 넘겨주어 객체를 생성한다.

위의 코드에서는 PhoneNumber 의 값은 같지만 hashCode 는 다르게 나온다.

얼핏 봤을 때는 코드가 잘 동작하는 것처럼 보인다.

PhoneNumber 클래스는 값 클래스이므로 ``map.get()`` 에 또다른 값 클래스를 넣어도 __동일하게 동작해야 한다.__

```java
public class HashMapTest {

   public static void main(String[] args) {
      Map<PhoneNumber, String> map = new HashMap<>();

      PhoneNumber number1 = new PhoneNumber(123, 456, 7890);
      PhoneNumber number2 = new PhoneNumber(123, 456, 7890);

//         TODO 같은 인스턴스인데 다른 hashCode
//         다른 인스턴스인데 같은 hashCode를 쓴다면?
      System.out.println(number1.equals(number2));
      System.out.println(number1.hashCode());
      System.out.println(number2.hashCode());

      map.put(number1, "keesun");
      map.put(number2, "whiteship");

      String s = map.get(new PhoneNumber(123, 456, 7890)); // 제대로 동작하지 않는다.
      System.out.println(s);
   }
}
```

위의 코드는 제대로 동작하지 않는다.

HashMap 에 값을 넣을때와 __hashCode()__ 메서드를 실행해 어느 버킷에 넣을지 정하게 된다.

값을 꺼낼 때도 __key 에 대한 hashCode 값__ 을 통해서 버킷에서 객체를 꺼내오게 된다.

PhoneNumber 클래스에 __hashCode__ 를 정의하지 않았기 때문에 

``map.get(new PhoneNumber(123, 456, 7890))`` 부분에서 버킷을 찾지 못하는 것이다.

hash 를 기반으로 만들어진 Map 이기 때문에 HashMap 이라고 불린다.

이러한 이유로 인해 __equals 가 같다면 같은 HashCode 를 리턴해야한다.__

만약 다른 인스턴스인데 같은 __hashCode__ 값을 가지면 어떻게 될까?

```java
public final class PhoneNumber {
   private final short areaCode, prefix, lineNum;

   public PhoneNumber(int areaCode, int prefix, int lineNum) {
      this.areaCode = rangeCheck(areaCode, 999, "area code");
      this.prefix   = rangeCheck(prefix,   999, "prefix");
      this.lineNum  = rangeCheck(lineNum, 9999, "line num");
   }

   private static short rangeCheck(int val, int max, String arg) {
      if (val < 0 || val > max)
         throw new IllegalArgumentException(arg + ": " + val);
      return (short) val;
   }

   @Override public boolean equals(Object o) {
      if (o == this)
         return true;
      if (!(o instanceof PhoneNumber))
         return false;
      PhoneNumber pn = (PhoneNumber)o;
      return pn.lineNum == lineNum && pn.prefix == prefix
            && pn.areaCode == areaCode;
   }
   
   @Override
    public int hashCode() {
        return 42;
    }
}
```

PhoneNumber 클래스가 항상 같은 hashCode 를 리턴하게 수정한다.

```java
public class HashMapTest {

   public static void main(String[] args) {
      Map<PhoneNumber, String> map = new HashMap<>();

      PhoneNumber number1 = new PhoneNumber(123, 456, 7890);
      PhoneNumber number2 = new PhoneNumber(456, 789, 1111);


      // 다른 인스턴스인데 같은 hashCode를 쓴다면?
      System.out.println(number1.equals(number2));
      System.out.println(number1.hashCode());
      System.out.println(number2.hashCode());

      map.put(number1, "keesun");
      map.put(number2, "whiteship");

      String s = map.get(number1); // "keesun"
      System.out.println(s);
   }
}
```
위의 코드에서 number1, number2 인스턴스는 equals 값이 다르지만 같은 hashCode 값을 가진다.

코드는 잘 동작한다.

number1, number2 인스턴스는 다른 객체임에도 불구하고 hashCode 값이 같으므로 __해시 충돌(Hash Collision)__ 이 발생한다.

HashMap 에서 __해시 충돌__ 이 발생하면 버킷에 들어있는 오브젝트를 __링크드 리스트__ 로 만든다.

__hashCode__ 가 같다면 모두 같은 __버킷__ 안으로 들어가게 된다.

__버킷__ 안에 링크드 리스트 안에 들어가게된다.

값을 가져올 때는 버킷안에 있는 __링크드 리스트__ 를 꺼내 __equals__ 를 비교한다.

즉, __해시 충돌__ 이 발생하면 __HashMap__ 을 사용하는 장점이 사라지는 셈이다.

---









