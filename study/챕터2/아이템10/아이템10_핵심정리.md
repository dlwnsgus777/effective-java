
## 아이템 10. equals 는 일반 규약을 지켜 재정의하라 - 핵심 정리
---

__모든 클래스는 전부 Object 클래스를 상속 받는다__

Object 클래스에 있는 메서드를 오버라이딩 할 수 있다.

이번 아이템에서는 __equals 메서드__ 에 대해서 다룬다.

equals 메서드는 직접 구현할 때도 있고 아닐 때도 있지만 보통은 IDE 나 Tool 을 사용해 equals 메서드를 정의하게 된다.

__equals 메서드__ 를 만들지 않아도 된다면 만들지 않는게 __최선이다.__

__equals 메서드__ 를 만들지 않아도 되는 상황은 다음과 같다.

#### 각 인스턴스가 본질적으로 고유할 때.

싱글톤 패턴을 구현했다고 가정해보자.

그 Object는 그 자체로 고유할 수 밖에 없다.

이런 상황에서는 굳이 __equals 메서드__ 가 필요하지 않다.

__enum 역시 근본적으로 단 하나만 존재__ 하기 때문에 마찬가지이다.

#### 인스턴스의 ‘논리적 동치성’을 검사할 필요가 없을 때

5천원 짜리 지폐 2장이 있다고 가정해보자.

5천원 짜리 지폐 2장은 같은 걸까, 다른 걸까?

이 질문의 대답은 어떤것이 같냐고 물어보느냐에 따라 다르다.

__값이 같냐고 물어본다면__ 5천원 지폐 2장은 같은 것이 된다.

이것을 __논리적 동치성__ 이라고 한다.

하지만 5천원 지폐 2장은 엄연히 다른 돈이다.

Object 가 제공하는 기본적인 __equals 메서드__ 는 객체의 동일성을 비교한다.

Object 가 제공하는 기본적인 __equals 메서드__ 로 따지자면 5천원 지폐 2장은 서로 다르다는 결과를 낸다.

대표적으로 문자열 같은 경우 __논리적 동치성__ 을 검사한다.

#### 상위 클래스에서 재정의한 equals 가 정의되어 있을 때

대표적인 경우로는 __List, Set__ 을 상속해서 구현하는 경우가 있다.

__List, Set__ 의 상위 클래스에에 __equals 메서드__ 가 구현되어있기 때문에 굳이 직접 구현할 필요가 없다.

#### 클래스가 private 이거나 package-private 이고 equals 메서드를 호출할 일이 없을 때

어딘가 굉장히 제한적인 클래스이고, 그 클래스에서 equals 메서드를 호출할 일이 없을 때는 

__equals 메서드__ 재정의할 필요가 없다.

public 클래스인 경우에는 __equals 메서드__ 가 호출이 되지 않을거라는 보장이 없다.

public 클래스를 __List, Set__ 에 넣게되면 __equals 메서드__ 가 호출된다.




