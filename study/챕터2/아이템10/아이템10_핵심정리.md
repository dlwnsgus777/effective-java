
## 아이템 10. equals 는 일반 규약을 지켜 재정의하라 - 핵심 정리
---

__모든 클래스는 전부 Object 클래스를 상속 받는다__

Object 클래스에 있는 메서드를 오버라이딩 할 수 있다.

이번 아이템에서는 __equals 메서드__ 에 대해서 다룬다.

equals 메서드는 직접 구현할 때도 있고 아닐 때도 있지만 보통은 IDE 나 Tool 을 사용해 equals 메서드를 정의하게 된다.

__equals 메서드__ 를 만들지 않아도 된다면 만들지 않는게 __최선이다.__

__equals 메서드__ 를 만들지 않아도 되는 상황은 다음과 같다.

#### 각 인스턴스가 본질적으로 고유할 때.

싱글톤 패턴을 구현했다고 가정해보자.

그 Object는 그 자체로 고유할 수 밖에 없다.

이런 상황에서는 굳이 __equals 메서드__ 가 필요하지 않다.

__enum 역시 근본적으로 단 하나만 존재__ 하기 때문에 마찬가지이다.

#### 인스턴스의 ‘논리적 동치성’을 검사할 필요가 없을 때

5천원 짜리 지폐 2장이 있다고 가정해보자.

5천원 짜리 지폐 2장은 같은 걸까, 다른 걸까?

이 질문의 대답은 어떤것이 같냐고 물어보느냐에 따라 다르다.

__값이 같냐고 물어본다면__ 5천원 지폐 2장은 같은 것이 된다.

이것을 __논리적 동치성__ 이라고 한다.

하지만 5천원 지폐 2장은 엄연히 다른 돈이다.

Object 가 제공하는 기본적인 __equals 메서드__ 는 객체의 동일성을 비교한다.

Object 가 제공하는 기본적인 __equals 메서드__ 로 따지자면 5천원 지폐 2장은 서로 다르다는 결과를 낸다.

대표적으로 문자열 같은 경우 __논리적 동치성__ 을 검사한다.

#### 상위 클래스에서 재정의한 equals 가 정의되어 있을 때

대표적인 경우로는 __List, Set__ 을 상속해서 구현하는 경우가 있다.

__List, Set__ 의 상위 클래스에에 __equals 메서드__ 가 구현되어있기 때문에 굳이 직접 구현할 필요가 없다.

#### 클래스가 private 이거나 package-private 이고 equals 메서드를 호출할 일이 없을 때

어딘가 굉장히 제한적인 클래스이고, 그 클래스에서 equals 메서드를 호출할 일이 없을 때는 

__equals 메서드__ 재정의할 필요가 없다.

public 클래스인 경우에는 __equals 메서드__ 가 호출이 되지 않을거라는 보장이 없다.

public 클래스를 __List, Set__ 에 넣게되면 __equals 메서드__ 가 호출된다.

---

__equals 메서드__ 를 재정의 해야하는 경우라면 몇가지 따라야할 규약이 있다.

#### 반사성

```java
A.equals(A) == true
```

반사성은 본인이 본인과 비교를 했을 떄 같다고 나와야하는 걸 말한다.

거울에 비친 것과 같다고 생각하면 된다.

#### 대칭성

```java
A.equals(B) == B.equals(A)
```

A 객체에서 B 객체를 비교한 결과와 B 객체에서 A 객체를 비교한 결과가 같아야한다.

둘 중 한쪽의 결과가 다르다면 __대칭성이 꺠진 것 이다.__

```java
// 코드 10-1 잘못된 코드 - 대칭성 위배! (54-55쪽)
public final class CaseInsensitiveString {
   private final String s;

   public CaseInsensitiveString(String s) {
      this.s = Objects.requireNonNull(s);
   }

   @Override public boolean equals(Object o) {
      if (o instanceof CaseInsensitiveString)
         return s.equalsIgnoreCase(
               ((CaseInsensitiveString) o).s);
      if (o instanceof String)  // 한 방향으로만 작동한다!
         return s.equalsIgnoreCase((String) o);
      return false;
   }
}
```
CaseInsensitiveString 클래스를 작성한다.

```java
   @Override public boolean equals(Object o) {
      if (o instanceof CaseInsensitiveString)
         return s.equalsIgnoreCase(
               ((CaseInsensitiveString) o).s); // 전달받은 Object 를 형변환 하여 필드값 비교
      if (o instanceof String)  // 한 방향으로만 작동한다!
         return s.equalsIgnoreCase((String) o); // 전달받은 Object가 String이라면 String과 문자열비교
      return false;
   }

```
위와 같이 __equals__ 메서드를 오버라이딩 하고있다.

CaseInsensitiveString 클래스를 String 클래스와 동급으로 사용하려하는 코드이다.

이렇게 코드를 작성하면 __대칭성이 깨진다.__

```java
public class main {
   public static void main(String[] args) {
      CaseInsensitiveString cis = new CaseInsensitiveString("Polish");
      String polish = "polish";
      System.out.println(cis.equals(polish)); // true 가 나온다.

      List<CaseInsensitiveString> list = new ArrayList<>();
      list.add(cis);

      System.out.println(list.contains(polish)); // false 가 나온다.
   }
}   
```
위의 코드에서 보면 CaseInsensitiveString 객체에서 String 객체를 비교하면 __true__ 가 나온다.

하지만 ``list.contains(polish)`` 코드에서는 __false__ 가 나온다.

``cis.equals(polish)`` 의 값과 ``polish.equals(cis)`` 의 값이 다르다는 뜻이다.

__String__ 클래스에서는 우리가 작성한 __CaseInsensitiveString__ 클래스 자체를 고려하지 않기때문이다.

```java
// 코드 10-1 잘못된 코드 - 대칭성 위배! (54-55쪽)
public final class CaseInsensitiveString {
   private final String s;

   public CaseInsensitiveString(String s) {
      this.s = Objects.requireNonNull(s);
   }

    @Override public boolean equals(Object o) {
        return o instanceof CaseInsensitiveString &&
                ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);
    }
}
```

대칭성을 위배하지 않으려면 __본인의 타입에 대해서만__ 비교를 해야한다.

__equals__ 메서드에서 다른 타입을 지원하면 __문제가 복잡해지고, 대칭성이 깨지기 쉽다.__

#### 추이성

```java
A.equals(B) && B.equals(C), A.equals(C)
```

A 객체와 B 객체가 같고 B 객체가 C 객체와 같으면 A 객체는 C 객체와 같다.

```java
public class Point {
   private final int x;
   private final int y;

   public Point(int x, int y) {
      this.x = x;
      this.y = y;
   }

   @Override public boolean equals(Object o) {
      if (this == o) {
         return true;
      }

      if (!(o instanceof Point)) {
         return false;
      }

      Point p = (Point) o;
      return p.x == x && p.y == y;
   }

   public static void main(String[] args) {
      Point point = new Point(1, 2);
      List<Point> points = new ArrayList<>();
      points.add(point);
      System.out.println(points.contains(new Point(1, 2)));
   }
   
   // 아이템 11 참조
   @Override public int hashCode()  {
      return 31 * x + y;
   }
}
```

Point 클래스를 작성한다.

여기까지는 깔끔하다.

문제는 상속을 받은 뒤에 생긴다.

```java
public class ColorPoint extends Point {
   private final Color color;

   public ColorPoint(int x, int y, Color color) {
      super(x, y);
      this.color = color;
   }
}
```

Point 클래스를 상속받은 ColorPont 클래스를 작성한다.

여기서 Color 는 

``public enum Color { RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET }``

이렇게 따로 enum 으로 생성한다.

Color 필드가 추가되었으니 __equals__ 메서드를 어떻게 정의해야할까?

```java
public class ColorPoint extends Point {
   private final Color color;

   public ColorPoint(int x, int y, Color color) {
      super(x, y);
      this.color = color;
   }

    @Override public boolean equals(Object o) {
        if (!(o instanceof ColorPoint))
            return false;
        return super.equals(o) && ((ColorPoint) o).color == color;
    }
}
```
부모 클래스의 equals 를 사용하고 color 를 다시 비교하는 방법이다.

겉으로는 좋아보이지만 __equals__ 메서드의 __대칭성을 깨뜨린다.__

```java
public class main {
   public static void main(String[] args) {
        Point p = new Point(1, 2);
        ColorPoint cp = new ColorPoint(1, 2, Color.RED);
        System.out.println(p.equals(cp) + " " + cp.equals(p));
   }
}   
```
Point 와 ColorPoint 클래스를 비교한다.

Point 클래스에서 ColorPoint 클래스를 비교하면 True 의 결과가 나오지만

ColorPoint 클래스에서 Point 클래스를 비교하면 False 의 결과가 나온다.

```java
@Override public boolean equals(Object o) {
        if (!(o instanceof ColorPoint))
            return false;
        return super.equals(o) && ((ColorPoint) o).color == color;
```

Point 클래스는 ColorPoint 타입이 아니기 때문에 위의 if 문에서 false 가 반환되게 된다.

그렇다면 타입을 고려해서 비교하면 어떻게 될까?

```java
public class ColorPoint extends Point {
   private final Color color;

   public ColorPoint(int x, int y, Color color) {
      super(x, y);
      this.color = color;
   }

   // 코드 10-3 잘못된 코드 - 추이성 위배! (57쪽)
   @Override public boolean equals(Object o) {
      if (!(o instanceof Point))
         return false;

      // o가 일반 Point면 색상을 무시하고 비교한다.
      if (!(o instanceof ColorPoint))
         return o.equals(this);

      // o가 ColorPoint면 색상까지 비교한다.
      return super.equals(o) && ((ColorPoint) o).color == color;
   }
}
```

위의 코드처럼 equals 메서드를 수정해보자.

위의 equals 메서드처럼 equals 를 작성하면

ColorPoint 클래스와 같은 레벨의 Point 를 상속받은 클래스를 equals 로 비교하게 되면

서로의  equals 를 계속 호출하게되어 __StackOverFlow__ 에러가 발생한다.

```java
public class main {
   public static void main(String[] args) {
      ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
      Point p2 = new Point(1, 2);
      ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);
      System.out.printf("%s %s %s%n",
            p1.equals(p2), p2.equals(p3), p1.equals(p3));
   }
}   
```
위의 코드를 실행해보면 __추이성이 깨지는 걸 확인할 수 있다.__

이러한 상황에서 추이성을 보장하기위해 상위 클래스는 상위 클래스에서 비교하고 

하위 클래스는 하위 클래스에서 비교시키려고 시도할 수도 있다.

```java
public class Point {
   private final int x;
   private final int y;

   public Point(int x, int y) {
      this.x = x;
      this.y = y;
   }

   // 잘못된 코드 - 리스코프 치환 원칙 위배! (59쪽)
    @Override public boolean equals(Object o) {
        if (o == null || o.getClass() != getClass())
            return false;
        Point p = (Point) o;
        return p.x == x && p.y == y;
    }

   // 아이템 11 참조
   @Override public int hashCode()  {
      return 31 * x + y;
   }
}
```
위처럼 ``getClass`` 를 통해 타입이 아닌 클래스를 꺼내서 비교하게 수정했다.

위처럼 작성하게되면 __리스코프 치환 원칙__ 을 위배하게 된다.

```java
public class CounterPoint extends Point {
    private static final AtomicInteger counter =
            new AtomicInteger();

    public CounterPoint(int x, int y) {
        super(x, y);
        counter.incrementAndGet();
    }
    public static int numberCreated() { return counter.get(); }
}
```
Point 를 상속받은 CounterPoint 클래스를 작성한다.

```java
// CounterPoint를 Point로 사용하는 테스트 프로그램
public class CounterPointTest {
    // 단위 원 안의 모든 점을 포함하도록 unitCircle을 초기화한다. (58쪽)
    private static final Set<Point> unitCircle = Set.of(
            new Point( 1,  0), new Point( 0,  1),
            new Point(-1,  0), new Point( 0, -1));

    public static boolean onUnitCircle(Point p) {
        return unitCircle.contains(p);
    }

    public static void main(String[] args) {
        Point p1 = new Point(1,  0);
        Point p2 = new CounterPoint(1, 0);

        // true를 출력한다.
        System.out.println(onUnitCircle(p1));

        // true를 출력해야 하지만, Point의 equals가 getClass를 사용해 작성되었다면 그렇지 않다.
        System.out.println(onUnitCircle(p2));
    }
}
```
CounterPoint 클래스는 Point 클래스에 재정의 되어있는 __equals__ 메서드를 사용한다.

``onUnitCircle(p1)`` 는 true 를 반환한다.

하지만 ``onUnitCircle(p2)`` 는 true 를 반환해야하지만 false 를 반환하게 된다.

__리스코프 치환 원칙__ 은 __상위 클래스 타입으로 동작하는 코드를 하위 클래스 타입의 인스턴스를 주더라도 그대로 동작해야한다__ 는 원칙이다.

즉, Point 클래스의 하위타입인 CounterPoint 클래스의 인스턴스를 파라미터로 주었을 때 동일한 결과가 나와야한다는 것이다.

위의 코드는 __리스코프 치환 원칙__ 을 위배한다.

Set 에서 __equals__ 메서드와 __hashcode__ 를 확인하는데 

Point 클래스의 __equals__ 메서드에서 ``getClass`` 를 사용하기 때문에 False 가 반환되는 것이다.

```java
public class Point {
   private final int x;
   private final int y;

   public Point(int x, int y) {
      this.x = x;
      this.y = y;
   }

   @Override public boolean equals(Object o) {
      if (!(o instanceof Point)) {
         return false;
      }
      Point p = (Point) o;
      return p.x == x && p.y == y;
   }

   public static void main(String[] args) {
      Point point = new Point(1, 2);
      List<Point> points = new ArrayList<>();
      points.add(point);
      System.out.println(points.contains(new Point(1, 2)));
   }
   
   // 아이템 11 참조
   @Override public int hashCode()  {
      return 31 * x + y;
   }
}
```

__instanceof__ 를 이용한다면 어떻게 될까?

```java
// CounterPoint를 Point로 사용하는 테스트 프로그램
public class CounterPointTest {
    // 단위 원 안의 모든 점을 포함하도록 unitCircle을 초기화한다. (58쪽)
    private static final Set<Point> unitCircle = Set.of(
            new Point( 1,  0), new Point( 0,  1),
            new Point(-1,  0), new Point( 0, -1));

    public static boolean onUnitCircle(Point p) {
        return unitCircle.contains(p);
    }

    public static void main(String[] args) {
        Point p1 = new Point(1,  0);
        Point p2 = new CounterPoint(1, 0);

        // true를 출력한다.
        System.out.println(onUnitCircle(p1));

        // true를 출력한다.
        System.out.println(onUnitCircle(p2));
    }
}
```
__리스코프 치환 원칙을 위반하지 않는다.__

상속을 사용하게되면 __equals__ 메서드를 재정의하는데 많은 문제가 생긴다.

상속받은 클래스에서 __아무런 필드도 추가하지 않았다면__ 상위 클래스의 __equals 메서드를 그대로 사용해도 된다.__

상위 클래스에서는 __하위 클래스를 고려할 필요없이 equals 메서드를 정의하면 된다.__

만약 상속을 받은뒤 __필드를 추가하게 된다면 equals 규약을 만족시키는 방법은 존재하지 않는다.__

이미 Java 코드에도 이런 경우가 존재한다.

```java
public class EqualsInJava extends Object {

   public static void main(String[] args) throws MalformedURLException {
      long time = System.currentTimeMillis();
      Timestamp timestamp = new Timestamp(time);
      Date date = new Date(time);

      // 대칭성 위배! P60
      System.out.println(date.equals(timestamp)); // true
      System.out.println(timestamp.equals(date)); // false
   }
}
```
대표적으로 Date 클래스를 상속받아 만든 Timestamp 클래스가 있다.

Timestamp 클래스와 Date 클래스는 __대칭성이 깨져있다.__

그래서 __컴포지션을 권장한다.__



#### 일관성

#### null 이 아님




