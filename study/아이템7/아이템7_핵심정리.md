
## 아이템 7 - 다 쓴 객체 참조를 해제하라 - 핵심 정리
---

모든 경우에 다 쓴 객체 참조를 해제하는 것은 아니다.

참조를 해제한다는 건 

```java
Book spring = new Book();
```
위에서 spring 이라는 변수는 Book을 참조하고 있는 것이다.

어떤 객체에 대한 레퍼런스가 남아있다면 해당 객체는 가비지 컬렉션의 대상이 되지 않는다.

만약 Book 을 다 사용했다면 

```java
spring = null;
```

이렇게 __null__ 을 할당함으로써 참조를 해제한다.

참조를 해제하는 건 예외적인 경우이지만 의외로 흔하다.

가비지 컬렉터가 있더라도 메모리 누수가 발생할 수 있기 때문이다.

책에서는 총 3가지의 경우에 대해 설명하고 있다.

#### Stack

```java
public class Stack {
   private Object[] elements;
   private int size = 0;
   private static final int DEFAULT_INITIAL_CAPACITY = 16;

   public Stack() {
      elements = new Object[DEFAULT_INITIAL_CAPACITY];
   }

   public void push(Object e) {
      ensureCapacity();
      elements[size++] = e;
   }

    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        return elements[--size];
    }

   /**
    * 원소를 위한 공간을 적어도 하나 이상 확보한다.
    * 배열 크기를 늘려야 할 때마다 대략 두 배씩 늘린다.
    */
   private void ensureCapacity() {
      if (elements.length == size)
         elements = Arrays.copyOf(elements, 2 * size + 1);
   }

   public static void main(String[] args) {
      Stack stack = new Stack();
      for (String arg : args)
         stack.push(arg);

      while (true)
         System.err.println(stack.pop());
   }
}
```
위의 코드에서는 스택에서 값을 빼도 배열에서 값이 사라지지 않는다.

위의 스택을 계속 사용하다보면 메모리가 계속 쌓이게되 에러가 발생하게 된다.

```java
public class Stack {
   private Object[] elements;
   private int size = 0;
   private static final int DEFAULT_INITIAL_CAPACITY = 16;

   public Stack() {
      elements = new Object[DEFAULT_INITIAL_CAPACITY];
   }

   public void push(Object e) {
      ensureCapacity();
      elements[size++] = e;
   }

   /**
    * 원소를 위한 공간을 적어도 하나 이상 확보한다.
    * 배열 크기를 늘려야 할 때마다 대략 두 배씩 늘린다.
    */
   private void ensureCapacity() {
      if (elements.length == size)
         elements = Arrays.copyOf(elements, 2 * size + 1);
   }

   // 코드 7-2 제대로 구현한 pop 메서드 (37쪽)
   public Object pop() {
      if (size == 0)
         throw new EmptyStackException();
      Object result = elements[--size];
      elements[size] = null; // 다 쓴 참조 해제
      return result;
   }

   public static void main(String[] args) {
      Stack stack = new Stack();
      for (String arg : args)
         stack.push(arg);

      while (true)
         System.err.println(stack.pop());
   }

}
```

위처럼 pop 메서드를 수정한다.

스택에서 값을 빼낼 때 빼낸 위치에 있는 객체의 참조를 해제한다.

pop 을 통해 가져간 클라이언트 쪽에서도 꺼내간 객체를 다 사용한 뒤 메서드가 끝나면

pop 을 했던 오브젝트의 생명주기도 끝나게 된다.

가비지 컬렉션의 대상이 되지 않는 경우는 

배열, List, Set, Map 등이 있다.

이렇게 __컬렉션에 뭔가를 쌓아놓는 경우__ 에는 항상 객체 참조에 대해 염두해서 사용해야한다.

#### Cache

```java
import java.util.HashMap;

public class PostRepository {

   private Map<CacheKey, Post> cache;

   public PostRepository() {
      this.cache = new HashMap<>();
   }

   public Post getPostById(Integer id) {
      CacheKey key = new CacheKey(id);
      if (cache.containsKey(key)) {
         return cache.get(key);
      } else {
         // TODO DB에서 읽어오거나 REST API를 통해 읽어올 수 있습니다.
         Post post = new Post();
         cache.put(key, post);
         return post;
      }
   }

   public Map<CacheKey, Post> getCache() {
      return cache;
   }
}
```
위의 코드는 포스트를 조회할 때마다 cache 가 계속 쌓이게 된다.

이럴때 사용할 수 있는 방법 중 하나가 __WeakHashMap__ 을 사용하는 것이다.

__WeakHashMap__ 은 __WeakReference__ 를 key 로 가지는 맵이다.

Reference 에는 Strong, Soft, Weak, Phantom 으로 총 4가지가 있다.

__WeakHashMap__ 은 key 가 더이상 참조가 되지 않으면(__WeakReference 제외__) 그 key 와 value 를 가비지 컬렉션시 삭제하게 된다.

```java
class PostRepositoryTest {
   @Test
   void cache() throws InterruptedException {
      PostRepository postRepository = new PostRepository();
      Integer key1 = 1;
      postRepository.getPostById(key1);

      assertFalse(postRepository.getCache().isEmpty()); // 캐시는 비어있지 않음

      // TODO run gc
      System.out.println("run gc");
      System.gc();
      System.out.println("wait");
      Thread.sleep(3000L);

      assertTrue(postRepository.getCache().isEmpty()); // 캐시는 비어있지 않음
   }
}   
```
위의 테스트 코드에서 __System.gc();__ 를 한다고 해서 바로 gc가 일어난다고 보장할 수는 없다.

```java
class PostRepositoryTest {
   @Test
   void cache() throws InterruptedException {
      PostRepository postRepository = new PostRepository();
      Integer key1 = 1;
      postRepository.getPostById(key1);

      assertFalse(postRepository.getCache().isEmpty()); // 캐시는 비어있지 않음
      
      p1 = null;

      // TODO run gc
      System.out.println("run gc");
      System.gc();
      System.out.println("wait");
      Thread.sleep(3000L);

      assertTrue(postRepository.getCache().isEmpty()); // 캐시는 비어있지 않음
   }
}   
```
테스트 코드에서 p1 변수를 null로 만들어도 cache 는 비워지지 않는다.






