
## 아이템 8 - finalizer 와 cleaner 사용을 피하라 - 핵심 정리
---

finalizer 와 cleaner 사용을 피해야한다.

__cleaner 는 자바9 버전부터 새로 들어온 기능이다.__

finalizer 와 cleaner 는 같인 일을 하는 기능, 자원을 반납하는 기능이다.

하지만 finalizer 와 cleaner 는 __즉시 수행한다는 보장이 없다.__

만약 객체가 가지고있던 일부 리소스를 제대로 정리하지 않고 객체를 소멸시키면 어떻게될까?

운영체제에서는 파일 핸들러와 운영체제마다 오픈할 수 있는 파일 갯수가 제한되어있다.

소켓 갯수 또한 제한이 있다.

소켓이나 파일을 만들때마다 __파일 핸들러가 만들어진다.__

무한정 파일 핸들러를 만들 수가 없다. 

즉, 파일들이 많이 열려있으면 더이상 파일을 열 수 없다는 에러가 발생한다.

이 근본적인 원인은 자원반납이 제대로 처리되지 않았기 때문이다.

그래서 객체를 소멸할 때 리소스를 적절한 타이밍에 정리를 하려고 만들어진게 __finalizer 와 cleaner 다.__

하지만 사실상 __finalizer 와 cleaner 는 사용할 수 없다__

특히나 __finalizer 사용은 위험하다.__

또한 __finalizer 와 cleaner 는 실행 자체가 안될 수도 있다.__

__finalizer 는 동작 중 예외가 발생하면 자원 정리 작업이 처리되지 않을수도 있다.__

---

#### finalizer

```java
public class FinalizerIsBad {

   @Override
   protected void finalize() throws Throwable {
      System.out.print("");
   }
}
```

finalizer 는 ```finalize``` 메서드를 오바라이딩하면 된다.

```java
    @Deprecated(since="9")
    protected void finalize() throws Throwable { }
```

```finalize``` 는 자바9 버전부터 사용을 자제하라고 권장하고 있다.

```java
public class App {
   /**
    * 코드 참고 https://www.baeldung.com/java-finalize
    */
   public static void main(String[] args) throws InterruptedException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
      int i = 0;
      while(true) {
         i++;
         new FinalizerIsBad();

         if ((i % 1_000_000) == 0) {
            Class<?> finalizerClass = Class.forName("java.lang.ref.Finalizer");
            Field queueStaticField = finalizerClass.getDeclaredField("queue");
            queueStaticField.setAccessible(true);
            ReferenceQueue<Object> referenceQueue = (ReferenceQueue) queueStaticField.get(null);

            Field queueLengthField = ReferenceQueue.class.getDeclaredField("queueLength");
            queueLengthField.setAccessible(true);
            long queueLength = (long) queueLengthField.get(referenceQueue);
            System.out.format("There are %d references in the queue%n", queueLength);
         }
      }
   }
}
```
가비지 컬렉션 대상이되면 ```Finalizer```  안에 있는 레퍼런스 큐에 들어가서 ``finalize()`` 메서드를 실행하게 된다.

위의 코드는 ``Finalizer``  안에 있는 레퍼런스 큐에 얼마나 객체가 쌓여있는지에 대한 코드이다.

객체를 만드느라 바빠서 ``Finalizer``  안에 있는 레퍼런스 큐를 정리하지 못해 

``Finalizer``  안에 있는 레퍼런스 큐의 사이즈가 크게 출력되는 경우도 있다.

``Finalizer``  안에 있는 __레퍼런스 큐를 정리하는 스레드의 우선순위가 낮기 때문이다.__

```java
public class FinalizerIsBad {

   @Override
   protected void finalize() throws Throwable {
      System.out.print("");
   }
}
```

위의 __finalize()__ 메서드에서 다른 오브젝트를 참조하거나, 자기 자신을 참조하게되면

사실상 __finalize()__ 메서드 실행시 오브젝트가 늘어나게 된다.

---

#### cleaner

__자바 9버전__ 부터는 __cleaner__ 를 사용할 수 있다.

```java
public class BigObject {
   private List<Object> resource;

   public BigObject(List<Object> resource) {
      this.resource = resource;
   }

   public static class ResourceCleaner implements Runnable {

      private List<Object> resourceToClean;

      public ResourceCleaner(List<Object> resourceToClean) {
         this.resourceToClean = resourceToClean;
      }

      @Override
      public void run() {
         resourceToClean = null;
         System.out.println("cleaned up.");
      }
   }
}
```
BigObject 클래스 안에 resource 필드가 있다.

resource 필드는 BigObject 클래스가 소멸될 때마다 정리되어야하는 리소스이다.

__리소스 정리 작업을 Runnable 의 구현체로 구현한다.__

주의할 점은 __inner class 로 만들거라면 static 클래스로 정의한다.__

또한 __절대로 BigObject 클래스에 대한 레퍼런스가 있으면 안된다.__

리소스 정리 작업을 Runnable 의 구현체에서 정리하려는 Object 를 참조하면 안된다.

가비지 컬렉션이 될때 리소스 정리 작업을 Runnable 의 구현체에서 정리하려는 Object 를 참조하게 되면

__객체가 부활할 수 있다.__

```java
public class CleanerIsNotGood {
   public static void main(String[] args) throws InterruptedException {
      Cleaner cleaner = Cleaner.create(); // 클리너 생성

      List<Object> resourceToCleanUp = new ArrayList<>();
      BigObject bigObject = new BigObject(resourceToCleanUp); // 객체 생성
      
      // 클리너 등록
      cleaner.register(bigObject, new BigObject.ResourceCleaner(resourceToCleanUp));

      bigObject = null;
      System.gc();
      Thread.sleep(3000L);
   }
}
```
__cleaner 사용은 팬텀 레퍼런스 사용과 비슷하다.__

__cleaner 는 팬텀 레퍼런스를 사용해 만들어졌기 때문이다.__

위의 코드는 bigObject 가 GC의 대상이 될 때 resourceToCleanUp 의 자원을 해제하는 작업이다.



