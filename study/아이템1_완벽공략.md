## 아이템 1 - 생성자 대신 정적 팩터리 메서드를 고려하라 - 완벽 공략
---

### 열거 타입 = Enumeration

Enum 이란 상수 목록을 담을 수 있는 데이터 타입이다.

```java
public enum OrderStatus {
   ORDERED, SHIPPED, DELIVERED
}
```

가령 주문의 상태를 나타내는 필드가 있다고 가정해보면

```java
public class Order {

   private boolean prime;
   private boolean urgent;
   
   private OrderStatus status;

   public static Order primeOrder() {
      Order order = new Order();
      order.prime = true;

      return order;
   }

   public static Order urgentOrder() {
      Order order = new Order();
      order.urgent = true;
      return order;
   }
}
```
위와 같이 클래스를 구성할 수 있을 것이다.

하지만 Enum을 사용하지 않게된다면 

```java
public class Order {

   private boolean prime;
   private boolean urgent;

   // 0 - 주문 확인 중
   // 1 - 제품 준비 중
   // 2 - 배송 중
   // 3 - 배송 완료
   private int status;

   public static Order primeOrder() {
      Order order = new Order();
      order.prime = true;

      return order;
   }

   public static Order urgentOrder() {
      Order order = new Order();
      order.urgent = true;
      return order;
   }
}
```
위와 같이 주석을 추가하여 상태에 대한 자세한 설명이 필요했을 것이다.

심지어 __status__ 라는 값에 원하는 값이 아닌 다른 값이 들어갈 가능성이 생긴다.

하지만 __Enum__ 을 사용하면 __status__ 에 저장될 값을 제한 할 수 있다.

이걸 __Type - Safety__ 를 보장한다 말한다.

뿐만 아니라 Enum 인스턴스는 JVM 내에 하나만 존재하는 것이 보장되므로 싱글톤 패턴 구현시 유용하게 사용되기도 한다.

#### 질문 1) 특정 enum 타입이 가질 수 있는 모든 값을 순회하며 출력하라.

```java
public class Main {
   public static void main(String[] args) {
      Arrays.asList(OrderStatus.values()).forEach(System.out::println);
   }
}
```

#### 질문 2) enum 은 자바 클래스처럼 생성자, 메소드, 필드를 가질 수 있는가?

```java
public enum OrderStatus {
   ORDERED(0), SHIPPED(1), DELIVERED(2);

   private int statusIntValue;

   OrderStatus(int statusIntValue) {
      this.statusIntValue = statusIntValue;
   }
}
```

__enum 의 생성자는 private 이기 떄문에 외부에서 접근할 수 없다.__

#### 질문 3) enum 의 값은 == 연산자로 동일성을 비교할 수 있는가?

```java
public class Main {
   public static void main(String[] args) {
      if (order.status == OrderStatus.ORDERED) {

      }
   }
}
```

이런식으로 == 비교가 가능하다. 

__== 비교는  NullPointException 이 발생하지 않기때문에 equals 를 사용한 비교보다 안전하다.__

#### 과제) enum 을 key 로 사용하는 Map 을 정의하세요. 또는 enum 을 담고 있는 Set 을 만들어 보세요.



---

### 플라이웨이트 패턴

같은 객체가 자주 요쳥되는 상황에서는 플라이웨이트 패턴을 사용할 수 있다.

여기서 중요한건 __같은 객체__ 가 __자주 사용된다__ 이다.

같은 객체가 자주 사용되니 어딘가에 저장해두던가 캐싱을 사용할 수 있다.

플라이웨이트 패턴은 객체를 재사용하는 방법이다.

플라이웨이트 패턴은 객체를 가볍게 만들어 메모리 사용을 줄이는 패턴이다.

객체 안에서 자주 변경되는 속성과 변경되지 않는 속성을 분리해서 

변경되지 않는 속성을 Flyweight Factory 에 모아두고 Flyweight Factory 에서 꺼내 쓰는 방법이다.

Flyweight Factory 는 개념적 용어이다.

간단히말해 변경되지 않는 속성을 __어딘가에__ 모아두고 그 __어딘가에__ 서 꺼내 쓰는 방법이다.

```java
public class Character {

   private char value;
   private String color;
   private String fontFamily;
   private int fontSize;

   public Character(char value, String color, String fontFamily, int fontSize) {
      this.value = value;
      this.color = color;
      this.fontFamily = fontFamily;
      this.fontSize = fontSize;
   }
}
```
__Character__ 라는 클래스가 있다고 하자.

여기서 __fontFamily__ 와 __fontSize__ 는 주로 변경하지 않는 값이다. 

```java
public class Character {

   private char value;
   private String color;
   private Font font;

   public Character(char value, String color, Font font) {
      this.value = value;
      this.color = color;
      this.font = font;
   } 
}
```

```java
public class Font {

   private String fontFamily;
   private int fontSize;

   public Font(String fontFamily, int fontSize) {
      this.fontFamily = fontFamily;
      this.fontSize = fontSize;
   }
}
```
__fontFamily__ 와 __fontSize__ 를 __Font__ 라는 클래스로 값을 따로 모아두었다.



