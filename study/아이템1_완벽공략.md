## 아이템 1 - 생성자 대신 정적 팩터리 메서드를 고려하라 - 완벽 공략
---

### 열거 타입 = Enumeration

Enum 이란 상수 목록을 담을 수 있는 데이터 타입이다.

```java
public enum OrderStatus {
   ORDERED, SHIPPED, DELIVERED
}
```

가령 주문의 상태를 나타내는 필드가 있다고 가정해보면

```java
public class Order {

   private boolean prime;
   private boolean urgent;
   
   private OrderStatus status;

   public static Order primeOrder() {
      Order order = new Order();
      order.prime = true;

      return order;
   }

   public static Order urgentOrder() {
      Order order = new Order();
      order.urgent = true;
      return order;
   }
}
```
위와 같이 클래스를 구성할 수 있을 것이다.

하지만 Enum을 사용하지 않게된다면 

```java
public class Order {

   private boolean prime;
   private boolean urgent;

   // 0 - 주문 확인 중
   // 1 - 제품 준비 중
   // 2 - 배송 중
   // 3 - 배송 완료
   private int status;

   public static Order primeOrder() {
      Order order = new Order();
      order.prime = true;

      return order;
   }

   public static Order urgentOrder() {
      Order order = new Order();
      order.urgent = true;
      return order;
   }
}
```
위와 같이 주석을 추가하여 상태에 대한 자세한 설명이 필요했을 것이다.

심지어 __status__ 라는 값에 원하는 값이 아닌 다른 값이 들어갈 가능성이 생긴다.

하지만 __Enum__ 을 사용하면 __status__ 에 저장될 값을 제한 할 수 있다.

이걸 __Type - Safety__ 를 보장한다 말한다.

뿐만 아니라 Enum 인스턴스는 JVM 내에 하나만 존재하는 것이 보장되므로 싱글톤 패턴 구현시 유용하게 사용되기도 한다.

#### 질문 1) 특정 enum 타입이 가질 수 있는 모든 값을 순회하며 출력하라.

```java
public class Main {
   public static void main(String[] args) {
      Arrays.asList(OrderStatus.values()).forEach(System.out::println);
   }
}
```

#### 질문 2) enum 은 자바 클래스처럼 생성자, 메소드, 필드를 가질 수 있는가?

```java
public enum OrderStatus {
   ORDERED(0), SHIPPED(1), DELIVERED(2);

   private int statusIntValue;

   OrderStatus(int statusIntValue) {
      this.statusIntValue = statusIntValue;
   }
}
```

__enum 의 생성자는 private 이기 떄문에 외부에서 접근할 수 없다.__

#### 질문 3) enum 의 값은 == 연산자로 동일성을 비교할 수 있는가?

```java
public class Main {
   public static void main(String[] args) {
      if (order.status == OrderStatus.ORDERED) {

      }
   }
}
```

이런식으로 == 비교가 가능하다. 

__== 비교는  NullPointException 이 발생하지 않기때문에 equals 를 사용한 비교보다 안전하다.__

#### 과제) enum 을 key 로 사용하는 Map 을 정의하세요. 또는 enum 을 담고 있는 Set 을 만들어 보세요.

```java
public class Item01Main {
   public static void main(String[] args) {
      Map<OrderStatus, String> enumMap = new EnumMap<>(OrderStatus.class);

      EnumSet<OrderStatus> enumSet = EnumSet.allOf(OrderStatus.class);
   }
}
```

__EnumMap__ 을 사용하면 성능상 이점을 가져올 수 있다.

__HashMap__ 은 hash 값을 계산하여 table 을 제어하는 형식으로 데이터를 관리하지만

__EnumMap__ 은 열거형 상수가 정의된 순서를 가지고, 배열의 index만 가져오면 되기때문에 대부분의 상황에서 성능이 더 좋다.

또한, __HashMap__ 은 일정 이상의 자료가 저장되면 __resizing__ 을 하지만 

__EnumMap__ 은 시작부터 데이터의 사이즈가 __enum__ 으로 제한되기 때문에 더 빠른 해시 계산과 같은 몇가지 추가 성능 최적화를 

수행할 수 있습니다.

__HashSet__ 은 __HashMap__ 과 같이 __map__ 의 value가 있다, 없다를 표현하는 지시자 같은 값이 들어가게 된다.

반면 __EnumSet__ 은 값이 있다 없다만 표시하면 되니 10101011 와 같은 __비트 백터__ 로 구현이 가능하다.

---

### 플라이웨이트 패턴

같은 객체가 자주 요쳥되는 상황에서는 플라이웨이트 패턴을 사용할 수 있다.

여기서 중요한건 __같은 객체__ 가 __자주 사용된다__ 이다.

같은 객체가 자주 사용되니 어딘가에 저장해두던가 캐싱을 사용할 수 있다.

플라이웨이트 패턴은 객체를 재사용하는 방법이다.

플라이웨이트 패턴은 객체를 가볍게 만들어 메모리 사용을 줄이는 패턴이다.

객체 안에서 자주 변경되는 속성과 변경되지 않는 속성을 분리해서 

변경되지 않는 속성을 Flyweight Factory 에 모아두고 Flyweight Factory 에서 꺼내 쓰는 방법이다.

Flyweight Factory 는 개념적 용어이다.

간단히말해 변경되지 않는 속성을 __어딘가에__ 모아두고 그 __어딘가에__ 서 꺼내 쓰는 방법이다.

```java
public class Character {

   private char value;
   private String color;
   private String fontFamily;
   private int fontSize;

   public Character(char value, String color, String fontFamily, int fontSize) {
      this.value = value;
      this.color = color;
      this.fontFamily = fontFamily;
      this.fontSize = fontSize;
   }
}
```
__Character__ 라는 클래스가 있다고 하자.

여기서 __fontFamily__ 와 __fontSize__ 는 주로 변경하지 않는 값이다. 

```java
public class Character {

   private char value;
   private String color;
   private Font font;

   public Character(char value, String color, Font font) {
      this.value = value;
      this.color = color;
      this.font = font;
   } 
}
```

```java
public class Font {

   private String fontFamily;
   private int fontSize;

   public Font(String fontFamily, int fontSize) {
      this.fontFamily = fontFamily;
      this.fontSize = fontSize;
   }
}
```
__fontFamily__ 와 __fontSize__ 를 __Font__ 라는 클래스로 값을 따로 모아두었다.

```java
public class FontFactory {

   private Map<String, Font> cache = new HashMap<>();

   public Font getFont(String font) {
      if (cache.containsKey(font)) {
         return cache.get(font);
      } else {
         String[] split = font.split(":");
         Font newFont = new Font(split[0], Integer.parseInt(split[1]));
         cache.put(font, newFont);
         return newFont;
      }
   }
}
```
__FontFactory__ 를 만들어 자주 사용하는 값들을 캐싱하는 로직을 추가한다.

```java
public class HelloWorld {
   public static void main(String[] args) {
      FontFactory fontFactory = new FontFactory();

      Character c1 = new Character('h', "white", fontFactory.getFont("nanum:12"));
      Character c2 = new Character('h', "white", fontFactory.getFont("nanum:12"));
      Character c3 = new Character('h', "white", fontFactory.getFont("nanum:12"));
   }
}
```
위와 같이 __FontFactory__ 를 통해 자주 사용하는 객체를 캐싱해 사용할 수 있다.

```java
public class FontFactory {

   private static Map<String, Font> cache = new HashMap<>();

   public static Font getFont(String font) {
      if (cache.containsKey(font)) {
         return cache.get(font);
      } else {
         String[] split = font.split(":");
         Font newFont = new Font(split[0], Integer.parseInt(split[1]));
         cache.put(font, newFont);
         return newFont;
      }
   }
}
```
또한 __정적 팩토리 메서드__ 를 사용하여 캐싱된 객체를 받을 수 있다.

플라이웨이트 패턴을 사용하면 메모리 사용량을 줄일 수 있다.

---

### 인터페이스와 정적 메서드

#### 자바 8과 9에서 주요 인터페이스의 변화


자바 8 이후로는 인터페이스에 메서드를 정의할 수 있다.

이때 __default__ 라는 키워드를 메서드에 붙여야한다.

이를 __기본 메서드__ 라고 한다.

__기본 메서드__ 는 인스턴스에서만 사용할 수 있다.

```java
public interface HelloService {
   String hello();
   
   default String hi() {
      return "Hi";   
   }
}
```
자바 9버전에서는 인터페이스에서 __private static__ 메서드를 정의할 수 있다.

```java
public interface HelloService {
    String hello();

    default String hi() {
        return "Hi";
    }

    private static HelloService of(String lang) {
        if (lang.equals("ko")) {
            return new KoreanHelloService();
        } else {
            return new EnglishHelloService();
        }
    }
}
```
이러한 인터페이스의 변화로 인해 8버전, 9버전 이후로는 

인터페이스들의 기능들이 풍부해졌다.

그렇기 때문에 __인스턴스화 불가 클래스__ 를 만들 이유가 많이 줄어들었다.

그러나 인터페이스는 프라이빗한 필드를 가질 수 없기 때문에

프리이빗한 필드를 사용하는 Helper나 유틸리티 클래스를 만들어야 하는 경우도 있다.

#### 질문1) 내림차순으로 정렬하는 Comparator 를 만들고 List<Integer>를 정렬하라.

```java
public class Item01Main {
   public static void main(String[] args) {
      List<Integer> numbers = new ArrayList<>();
      numbers.add(100);
      numbers.add(20);
      numbers.add(33);
      numbers.add(3);

      System.out.println(numbers);

      Comparator<Integer> desc = new Comparator<>() {
         @Override
         public int compare(Integer t1, Integer t2) {
            return t2 - t1;
         }
      };

      Collections.sort(numbers, desc);

      System.out.println(numbers);
   }
}
```
#### 질문2) 질문1에서 만든 Comparator를 사용해서 오름차순으로 정렬하라.

```java
public class Item01Main {
   public static void main(String[] args) {
      List<Integer> numbers = new ArrayList<>();
      numbers.add(100);
      numbers.add(20);
      numbers.add(33);
      numbers.add(3);

      System.out.println(numbers);

      Comparator<Integer> desc = new Comparator<>() {
         @Override
         public int compare(Integer t1, Integer t2) {
            return t2 - t1;
         }
      };

      Collections.sort(numbers, desc.reversed());

      System.out.println(numbers);
   }
}
```
---
### 서비스 제공자 프레임워크


