
## 아이템 3 - 생성자나 열거 타입으로 싱글턴임을 보증하라.
---

애플리케이션을 만들다보면 어떤 인스턴스가 애플리케이션에서 __하나만__ 있어야 하는 경우

혹은 하나만 꼭 유지해야하는 경우가 있다.

예를들어 어떤 설정값을 저장하는 인스턴스 등이 있다.

이러한 상황일 때 사용하는 것이 싱글턴이다.

싱글턴을 만드는 방법은 여러가지가 있다.

---

### 첫번째 : private 생성자 + public static final 필드

```java
public class Elvis {

   /**
    * 싱글톤 오브젝트
    */
   public static final Elvis INSTANCE = new Elvis();
   
   private Elvis() {}
   
   public void leaveTheBuilding() {
      System.out.println("Whoa baby, I'm outta here!");
   }
   
   public void sing() {
      System.out.println("I'll have a blue~ Christmas without you~");
   }
}
```

private 생성자를 사용하여 외부에서 생성자를 호출할 수 없게 만들었다.

__public static final 필드__ 를 이용해 해당 클래스 타입의 인스턴스를 만든다.

```java
   public static void main(String[] args) {
      Elvis elvis = Elvis.INSTANCE;
      elvis.leaveTheBuilding();
      }
```

헤딩 클래스를 사용하는 클라이언트 코드는 위와같이 인스턴스를 사용하게 된다.

장점으로는 

- 코드가 간결하다.
- 자바 docs를 만들때 주석을 통해 api 문서에 드러낼 수 있다.

단점으로는 

### 단점 1. 싱글톤을 사용하는 클라이언트 코드를 테스트하기 어려워진다.

인터페이스 없이 싱글톤을 정의한 경우 클라이언트 코드를 테스트하기 어려워진다.

```java
public class Concert {
   private boolean lightsOn;

   private boolean mainStateOpen;

   private Elvis elvis;

   public Concert(Elvis elvis) {
      this.elvis = elvis;
   }

   public void perform() {
      mainStateOpen = true;
      lightsOn = true;
      elvis.sing();
   }

   public boolean isLightsOn() {
      return lightsOn;
   }
   
   public boolean isMainStateOpen() {
      return mainStateOpen; 
   }
}
```

__Concert__ 라는 클래스가 있고 이 클래스에서는 __Elvis__ 를 사용하고있다.

즉, __Concert__ 라는 클래스가 __Elvis__ 클래스의 클라이언트 코드이다.

이 경우 __Elvis__ 클래스를 직접 사용하고 있기 때문에 테스트하기가 어려워진다.

물론 다음과 같이 테스트 코드를 작성할 수 있다.

```java
class ConcertTest {

   @Test
   void perform() {
      Concert concert = new Concert(Elvis.INSTANCE);
      concert.perform();

      Assertions.assertTrue(concert.isLightsOn());
      Assertions.assertTrue(concert.isMainStateOpen());
   }
}
```

만약 Elvis 클래스 가 외부 Api 를 호출하는 경우나 연산이 오래걸리는 작업이 있을수도 있다.

이때마다 테스트 코드를 통해 호출하는건 굉장히 비효율적이다.

인터페이스를 통해 코드를 개선해보면 다음과 같다.

```java
public interface IElvis {

   void leaveTheBuilding();

   void sing();
}

```

__IElvis__ 라는 인터페이스를 만든다.

```java
public class Elvis implements IElvis{

   /**
    * 싱글톤 오브젝트
    */
   public static final Elvis INSTANCE = new Elvis();

   private Elvis() {}

   public void leaveTheBuilding() {
      System.out.println("Whoa baby, I'm outta here!");
   }

   public void sing() {
      System.out.println("I'll have a blue~ Christmas without you~");
   }

   public static void main(String[] args) {
      Elvis elvis = Elvis.INSTANCE;
      elvis.leaveTheBuilding();
   }
}
```

__IElvis__ 를 __Elvis__ 를 통해 구현한다.

```java
public class Concert {
   private boolean lightsOn;

   private boolean mainStateOpen;

   private IElvis elvis;

   public Concert(IElvis elvis) {
      this.elvis = elvis;
   }

   public void perform() {
      mainStateOpen = true;
      lightsOn = true;
      elvis.sing();
   }

   public boolean isLightsOn() {
      return lightsOn;
   }

   public boolean isMainStateOpen() {
      return mainStateOpen;
   }
}

```
__Concert__ 클래스의 코드를 인터페이스 기반의 코드로 작성한다.

```java
class ConcertTest {

   @Test
   void perform() {
      Concert concert = new Concert(Elvis.INSTANCE);
      concert.perform();

      Assertions.assertTrue(concert.isLightsOn());
      Assertions.assertTrue(concert.isMainStateOpen());
   }
}
```