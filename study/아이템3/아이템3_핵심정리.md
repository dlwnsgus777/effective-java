
## 아이템 3 - 생성자나 열거 타입으로 싱글턴임을 보증하라.
---

애플리케이션을 만들다보면 어떤 인스턴스가 애플리케이션에서 __하나만__ 있어야 하는 경우

혹은 하나만 꼭 유지해야하는 경우가 있다.

예를들어 어떤 설정값을 저장하는 인스턴스 등이 있다.

이러한 상황일 때 사용하는 것이 싱글턴이다.

싱글턴을 만드는 방법은 여러가지가 있다.

---

### 첫번째 : private 생성자 + public static final 필드

```java
public class Elvis {

   /**
    * 싱글톤 오브젝트
    */
   public static final Elvis INSTANCE = new Elvis();
   
   private Elvis() {}
   
   public void leaveTheBuilding() {
      System.out.println("Whoa baby, I'm outta here!");
   }
   
   public void sing() {
      System.out.println("I'll have a blue~ Christmas without you~");
   }
}
```

private 생성자를 사용하여 외부에서 생성자를 호출할 수 없게 만들었다.

__public static final 필드__ 를 이용해 해당 클래스 타입의 인스턴스를 만든다.

```java
   public static void main(String[] args) {
      Elvis elvis = Elvis.INSTANCE;
      elvis.leaveTheBuilding();
      }
```

헤딩 클래스를 사용하는 클라이언트 코드는 위와같이 인스턴스를 사용하게 된다.

장점으로는 

- 코드가 간결하다.
- 자바 docs를 만들때 주석을 통해 api 문서에 드러낼 수 있다.

단점으로는 

### 단점 1. 싱글톤을 사용하는 클라이언트 코드를 테스트하기 어려워진다.

인터페이스 없이 싱글톤을 정의한 경우 클라이언트 코드를 테스트하기 어려워진다.

```java
public class Concert {
   private boolean lightsOn;

   private boolean mainStateOpen;

   private Elvis elvis;

   public Concert(Elvis elvis) {
      this.elvis = elvis;
   }

   public void perform() {
      mainStateOpen = true;
      lightsOn = true;
      elvis.sing();
   }

   public boolean isLightsOn() {
      return lightsOn;
   }
   
   public boolean isMainStateOpen() {
      return mainStateOpen; 
   }
}
```

__Concert__ 라는 클래스가 있고 이 클래스에서는 __Elvis__ 를 사용하고있다.

즉, __Concert__ 라는 클래스가 __Elvis__ 클래스의 클라이언트 코드이다.

이 경우 __Elvis__ 클래스를 직접 사용하고 있기 때문에 테스트하기가 어려워진다.

물론 다음과 같이 테스트 코드를 작성할 수 있다.

```java
class ConcertTest {

   @Test
   void perform() {
      Concert concert = new Concert(Elvis.INSTANCE);
      concert.perform();

      Assertions.assertTrue(concert.isLightsOn());
      Assertions.assertTrue(concert.isMainStateOpen());
   }
}
```

만약 Elvis 클래스 가 외부 Api 를 호출하는 경우나 연산이 오래걸리는 작업이 있을수도 있다.

이때마다 테스트 코드를 통해 호출하는건 굉장히 비효율적이다.

인터페이스를 통해 코드를 개선해보면 다음과 같다.

```java
public interface IElvis {

   void leaveTheBuilding();

   void sing();
}

```

__IElvis__ 라는 인터페이스를 만든다.

```java
public class Elvis implements IElvis{

   /**
    * 싱글톤 오브젝트
    */
   public static final Elvis INSTANCE = new Elvis();

   private Elvis() {}

   public void leaveTheBuilding() {
      System.out.println("Whoa baby, I'm outta here!");
   }

   public void sing() {
      System.out.println("I'll have a blue~ Christmas without you~");
   }

   public static void main(String[] args) {
      Elvis elvis = Elvis.INSTANCE;
      elvis.leaveTheBuilding();
   }
}
```

__IElvis__ 를 __Elvis__ 를 통해 구현한다.

```java
public class Concert {
   private boolean lightsOn;

   private boolean mainStateOpen;

   private IElvis elvis;

   public Concert(IElvis elvis) {
      this.elvis = elvis;
   }

   public void perform() {
      mainStateOpen = true;
      lightsOn = true;
      elvis.sing();
   }

   public boolean isLightsOn() {
      return lightsOn;
   }

   public boolean isMainStateOpen() {
      return mainStateOpen;
   }
}

```
__Concert__ 클래스의 코드를 인터페이스 기반의 코드로 작성한다.

이렇게하면 __IElvis__ 인터페이스를 구현한 임의의 클래스를 통해 테스트하기가 수월해진다.

```java
class ConcertTest {

   @Test
   void perform() {
      Concert concert = new Concert(new MockElvis());
      concert.perform();

      Assertions.assertTrue(concert.isLightsOn());
      Assertions.assertTrue(concert.isMainStateOpen());
   }
}
```

### 단점 2. 리플렉션으로 private 생성자를 호출할 수 있다.

__리플렉션__ 을 사용하면 싱글톤이 깨지게된다.

```java
   public static void main(String[] args) {
      try {
         Constructor<Elvis> defaultConstructor = Elvis.class.getDeclaredConstructor();
         defaultConstructor.setAccessible(true); // private 생성자 호출 가능하게 설정

         Elvis elvis1 = defaultConstructor.newInstance();
         Elvis elvis2 = defaultConstructor.newInstance();

         System.out.println(elvis1 == elvis2); // false
      } catch (NoSuchMethodException e) {
         e.printStackTrace();
      } catch (InvocationTargetException e) {
         e.printStackTrace();
      } catch (InstantiationException e) {
         e.printStackTrace();
      } catch (IllegalAccessException e) {
         e.printStackTrace();
      }
   }
```
__getDeclaredConstructor__ 메서드를 사용하면 private 생성자에 접근할 수 있다.

이렇게하면 여러개의 인스턴스를 만들 수 있게되고 인스턴스들은 서로 다르게된다.

```java
public class Elvis implements IElvis {

   /**
    * 싱글톤 오브젝트
    */
   public static final Elvis INSTANCE = new Elvis();
   
   private static boolean created;

   private Elvis() {
      if (created) {
         throw new UnsupportedOperationException("can't be created by constructor");
      }
      
      created = true;
   }

   public void leaveTheBuilding() {
      System.out.println("Whoa baby, I'm outta here!");
   }

   public void sing() {
      System.out.println("I'll have a blue~ Christmas without you~");
   }

   public static void main(String[] args) {
      Elvis elvis = Elvis.INSTANCE;
      elvis.leaveTheBuilding();
   }
}
```

다음과 같이 __private static__ 필드를 통해 최초의 인스턴스 생성 이후 

생성자에 접근하여 인스턴스를 생성하면 오류를 발생하도록 할 수 있다.

이렇게해서 __리플렉션__ 을 통해 싱글턴을 깨뜨릴 수 없게 막을 수 있다.

대신 __코드가 간결해진다는 장점은 사라지게 된다.__

### 단점 3. 역직렬화 할 때 새로운 인스턴스가 생길 수 있다.



