## 아이템 3 - 생성자나 열거 타입으로 싱글턴임을 보증하라 - 완벽 공략
---

### 메서드 참조 

메소드 하나만 호출하는 람다 표현식을 줄여쓰는 방법이다.

#### 스태틱 메소드 레퍼런스

```java
public class Person {
   LocalDate birthday;

   public Person() {

   }

   public Person(LocalDate birthday) {
      this.birthday = birthday;
   }

   public int getAge() {
      return LocalDate.now().getYear() - birthday.getYear();
   }

   public static int compareByAge(Person a, Person b) {
      return a.birthday.compareTo(b.birthday);
   }
}
```
__Person__ 이라는 클래스가 있다.

```java
   public static void main(String[] args) {
      List<Person> people = new ArrayList<>();
      people.add(new Person(LocalDate.of(1982, 7, 15)));
      people.add(new Person(LocalDate.of(2011, 3, 2)));
      people.add(new Person(LocalDate.of(2013, 1, 28)));

      people.sort(new Comparator<Person>() {
         @Override
         public int compare(Person a, Person b) {
            return a.birthday.compareTo(b.birthday);
         }
      });
   }
```
자바 8 이전에는 위와 같이 내부 클래스를 사용해 Comparator 클래스를 만들어 사용했다.

```java
      people.sort(new Comparator<Person>() {
         @Override
         public int compare(Person a, Person b) {
            return a.birthday.compareTo(b.birthday);
         }
      });
```
여기서 사용하는 __Comparator__ 클래스를 익명 내부 클래스라고 한다.

```java
people.sort((p1, p2) -> p1.birthday.compareTo(p2.birthday));
```

자바 8 이후로는 위와 같이 사용할 수 있게 되었다.

이 방법을 __람다 익스프레션__ 이라고 한다.

__람다 익스프레션__ 에서 간단히 메서드 호출을 한번 하게되는 경우가 있다.

즉, __람다 익스프레션__ 안에서 하는 일이 어떠한 메서드 하나를 호출하는 일이라면

__메서드 하나를 호출하는 일__ 을 메서드 레퍼런스를 통해 간추려서 사용할 수 있다.

메서드를 참조하는 방법이다.

일종의 람다 익스프레션을 만드는 일이라고 생각하면 좋다.

```java
   public static int compareByAge(Person a, Person b) {
      return a.birthday.compareTo(b.birthday);
   }
```
__Person__ 클래스의 compareByAge 메서드를 사용하여 메서드 레퍼런스를 사용하면

```java
   public static void main(String[] args) {
      List<Person> people = new ArrayList<>();
      people.add(new Person(LocalDate.of(1982, 7, 15)));
      people.add(new Person(LocalDate.of(2011, 3, 2)));
      people.add(new Person(LocalDate.of(2013, 1, 28)));

      people.sort(Person::compareByAge);
   }
```

__Person::compareByAge__ 이 부분을 메서드 레퍼런스라고 한다.

여기서는 static 메서드를 참조했다.

static 메서드를 참조하기 때문에 클래스 이름을 통해 참조했다.

Comparator 가 제공하는 메서드와 매칭이 되기때문에 사용할 수 있다.

```java
    int compare(T o1, T o2); // Comparator 가 제공해야하는 compare 2개의 인자를 받아 int를 리턴
```

#### 인스턴스 메서드 레퍼런스

인스턴스에 있는 메서드를 레퍼런스하려면 

인스턴스를 생성해 사용하면 된다.

```java
   public int compareByAge(Person a, Person b) {
      return a.birthday.compareTo(b.birthday);
   }
```

__Person__ 클래스 내부의 compareByAge 메서드를 위와 같이 인스턴스 메소드로 변경하고

```java
   public static void main(String[] args) {
      List<Person> people = new ArrayList<>();
      people.add(new Person(LocalDate.of(1982, 7, 15)));
      people.add(new Person(LocalDate.of(2011, 3, 2)));
      people.add(new Person(LocalDate.of(2013, 1, 28)));
      
      Person person = new Person(null);

      people.sort(person::compareByAge);
   }
```
위와같이 인스턴스를 통해 메서드를 레퍼런스할 수 있다.

#### 임의 객체의 인스턴스 메소드 레퍼런스

```java
   public static void main(String[] args) {
      List<Person> people = new ArrayList<>();
      people.add(new Person(LocalDate.of(1982, 7, 15)));
      people.add(new Person(LocalDate.of(2011, 3, 2)));
      people.add(new Person(LocalDate.of(2013, 1, 28)));
      
      people.sort(Person::compareByAge);
   }
```

위와같이 임의 객체의 인스턴스 메서드를 레퍼런스 할 수 있다.

컴파일러에서는 빨간줄이 뜨지만 호환 가능한 상태가 아니라 그렇다.

```java
   public int compareByAge(Person b) {
      return this.birthday.compareTo(b.birthday);
      }
```

위와같이 __Person__ 클래스의 메서드를 변경한다.

임의 객체에 대한 인스턴스 메서드 레퍼런스는 첫번째 인자가 __자기자신__ 이 된다.

때문에 __메서드의 인자가 하나만 있어도 된다.__

__임의 객체의 인스턴스 메서드를 레퍼런스__ 인 경우에만 첫번째 인자가 __자기자신__ 이 된다.

#### 생성자 레퍼런스

```java
   public static void main(String[] args) {
      List<LocalDate> dates = new ArrayList<>();
      dates.add(LocalDate.of(1993, 9, 27));
      dates.add(LocalDate.of(1993, 9, 3));
      dates.add(LocalDate.of(2022, 6, 28));

      dates.stream().map(Person::new).collect(Collectors.toList());
   }
```
메서드 레퍼런스는 메서드 호출을 한번하는 람다를 간추리는 것이기 때문에

위와같이 생성자를 레퍼런스 할 수 있다.

```java
   public Person() {

   }

   public Person(LocalDate birthday) {
      this.birthday = birthday;
   }
```
만약 생성자가 2개가 있을 때 인자가 없는 생성자를 사용하고 싶으면 어떻게 해야할까?

함수형 인터페이스를 살펴보면서 알아보자.

### 함수형 인터페이스

자바 8부터 사용할 수 있는 기술이다.

자바는 함수형 인터페이스라는 기본 인터페이스를 제공한다.

함수형 인터페이스는 __타겟 타입__ 을 지정할 수 있다.

```java
   public static void main(String[] args) {
      List<LocalDate> dates = new ArrayList<>();
      dates.add(LocalDate.of(1982, 7, 15));
      dates.add(LocalDate.of(2011, 3, 2));
      dates.add(LocalDate.of(2013, 1, 28));

      List<Integer> before2000 = dates.stream()
            .filter(d -> d.isBefore(LocalDate.of(2000, 1, 1)))
            .map(LocalDate::getYear)
            .collect(Collectors.toList());
   }
```
__람다 익스프레션, 함수 레퍼런스__ 부분을 변수로 뺴보면 둘에 대한 타겟 타입이 정의 되어있다.

```java
      Predicate<LocalDate> localDatePredicate = d -> d.isBefore(LocalDate.of(2000, 1, 1));
      Function<LocalDate, Integer> getYear = LocalDate::getYear;

      List<Integer> before2000 = dates.stream()
      .filter(localDatePredicate)
      .map(getYear)
      .collect(Collectors.toList());
```
여기서 __Predicate__ , __Function__ 이 함수형 인터페이스이다.

```java
@FunctionalInterface
public interface MyFunction {
   
   String valueOf(Integer integer);
}
```
위와 같이 함수형 인터페이스를 정의할수도 있다.

인터페이스 안에 메서드 선언이 하나만 있으면 된다.

인터페이스 안에 static 메서드를 만들어도 되지만 구현이 비어있는 선언은 오직 하나만 있어야한다.

이러한 인터페이스에만 __@FunctionalInterface__ 를 붙일 수 있다.

__@FunctionalInterface__ 가 없어도 함수형 인터페이스로 간주가 된다.

중요한건 __구현이 비어있는 선언은 오직 하나만 있어야한다__ 는 점이다.

```java
      Function<Integer, String> intToString; // <input, output>
      Supplier<Integer> integerSupplier; // <output>
      Consumer<Integer> integerConsumer;
      Predicate<Integer> integerPredicate;
```

자바가 기본으로 제공하는 함수형 인터페이스가 굉장히 많지만 위의 4개를 알면 다른 인터페이스를 알기가 수월해진다.

__Function<Integer, String>__ 2개의 제너릭타입이 있는데

1번째는 input, 두번째는 output 이다.

여기서는 int를 받고 String을 리턴하는 함수다.

```java
Function<Integer, String> intToString = integer -> integer.toString();
Function<Integer, String> intToString = Object::toString;
```
위와같이 정의해 사용할 수 있다.

__Supplier<Integer>__ 는 output만 있는 경우이다.

인자가 없이 리턴만 하는 경우다.

__Supplier<Person>__ 이라면 Person을 리턴하는 메서드가 된다.

```java
Supplier<Person> integerSupplier = Person::new;
```
위와같이 하면 기본 생성자를 참조할 수 있게된다.

```java
Function<LocalDate, Person> personFunction = Person::new;
```
위는 LocalDate를 이용해 Person을 사용하는 생성자를 참조한다.

__Consumer<Integer>__ 같은 경우는 받는 건 있지만 리턴이 없는 경우다.

대표적인 예로는 __System.out.println__ 이 있다.

```java
Consumer<Integer> integerConsumer = System.out::println;
```

__Predicate<Integer>__ 은 Integer 를 받아서 __Boolean__ 을 리턴한다.

무조건 __Boolean__ 을 리턴하기 때문에 리턴타입은 정의하지 않는다.

나머지들은 위의 4가지 함수형 인터페이스에서 파생된 것들이다.

