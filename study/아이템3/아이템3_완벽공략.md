## 아이템 3 - 생성자나 열거 타입으로 싱글턴임을 보증하라 - 완벽 공략
---

### 메서드 참조 

메소드 하나만 호출하는 람다 표현식을 줄여쓰는 방법이다.

#### 스태틱 메소드 레퍼런스

```java
public class Person {
   LocalDate birthday;

   public Person() {

   }

   public Person(LocalDate birthday) {
      this.birthday = birthday;
   }

   public int getAge() {
      return LocalDate.now().getYear() - birthday.getYear();
   }

   public static int compareByAge(Person a, Person b) {
      return a.birthday.compareTo(b.birthday);
   }
}
```
__Person__ 이라는 클래스가 있다.

```java
   public static void main(String[] args) {
      List<Person> people = new ArrayList<>();
      people.add(new Person(LocalDate.of(1982, 7, 15)));
      people.add(new Person(LocalDate.of(2011, 3, 2)));
      people.add(new Person(LocalDate.of(2013, 1, 28)));

      people.sort(new Comparator<Person>() {
         @Override
         public int compare(Person a, Person b) {
            return a.birthday.compareTo(b.birthday);
         }
      });
   }
```
자바 8 이전에는 위와 같이 내부 클래스를 사용해 Comparator 클래스를 만들어 사용했다.

```java
      people.sort(new Comparator<Person>() {
         @Override
         public int compare(Person a, Person b) {
            return a.birthday.compareTo(b.birthday);
         }
      });
```
여기서 사용하는 __Comparator__ 클래스를 익명 내부 클래스라고 한다.

```java
people.sort((p1, p2) -> p1.birthday.compareTo(p2.birthday));
```

자바 8 이후로는 위와 같이 사용할 수 있게 되었다.

이 방법을 __람다 익스프레션__ 이라고 한다.

__람다 익스프레션__ 에서 간단히 메서드 호출을 한번 하게되는 경우가 있다.

즉, __람다 익스프레션__ 안에서 하는 일이 어떠한 메서드 하나를 호출하는 일이라면

__메서드 하나를 호출하는 일__ 을 메서드 레퍼런스를 통해 간추려서 사용할 수 있다.

메서드를 참조하는 방법이다.

일종의 람다 익스프레션을 만드는 일이라고 생각하면 좋다.

```java
   public static int compareByAge(Person a, Person b) {
      return a.birthday.compareTo(b.birthday);
   }
```
__Person__ 클래스의 compareByAge 메서드를 사용하여 메서드 레퍼런스를 사용하면

```java
   public static void main(String[] args) {
      List<Person> people = new ArrayList<>();
      people.add(new Person(LocalDate.of(1982, 7, 15)));
      people.add(new Person(LocalDate.of(2011, 3, 2)));
      people.add(new Person(LocalDate.of(2013, 1, 28)));

      people.sort(Person::compareByAge);
   }
```

__Person::compareByAge__ 이 부분을 메서드 레퍼런스라고 한다.

여기서는 static 메서드를 참조했다.

static 메서드를 참조하기 때문에 클래스 이름을 통해 참조했다.

Comparator 가 제공하는 메서드와 매칭이 되기때문에 사용할 수 있다.

```java
    int compare(T o1, T o2); // Comparator 가 제공해야하는 compare 2개의 인자를 받아 int를 리턴
```

#### 인스턴스 메서드 레퍼런스

인스턴스에 있는 메서드를 레퍼런스하려면 

인스턴스를 생성해 사용하면 된다.

```java
   public int compareByAge(Person a, Person b) {
      return a.birthday.compareTo(b.birthday);
   }
```

__Person__ 클래스 내부의 compareByAge 메서드를 위와 같이 인스턴스 메소드로 변경하고

```java
   public static void main(String[] args) {
      List<Person> people = new ArrayList<>();
      people.add(new Person(LocalDate.of(1982, 7, 15)));
      people.add(new Person(LocalDate.of(2011, 3, 2)));
      people.add(new Person(LocalDate.of(2013, 1, 28)));
      
      Person person = new Person(null);

      people.sort(person::compareByAge);
   }
```
위와같이 인스턴스를 통해 메서드를 레퍼런스할 수 있다.

#### 임의 객체의 인스턴스 메소드 레퍼런스

```java
   public static void main(String[] args) {
      List<Person> people = new ArrayList<>();
      people.add(new Person(LocalDate.of(1982, 7, 15)));
      people.add(new Person(LocalDate.of(2011, 3, 2)));
      people.add(new Person(LocalDate.of(2013, 1, 28)));
      
      people.sort(Person::compareByAge);
   }
```

위와같이 임의 객체의 인스턴스 메서드를 레퍼런스 할 수 있다.

컴파일러에서는 빨간줄이 뜨지만 호환 가능한 상태가 아니라 그렇다.

```java
   public int compareByAge(Person b) {
      return this.birthday.compareTo(b.birthday);
      }
```

위와같이 __Person__ 클래스의 메서드를 변경한다.

임의 객체에 대한 인스턴스 메서드 레퍼런스는 첫번째 인자가 __자기자신__ 이 된다.

때문에 __메서드의 인자가 하나만 있어도 된다.__

__임의 객체의 인스턴스 메서드를 레퍼런스__ 인 경우에만 첫번째 인자가 __자기자신__ 이 된다.

#### 생성자 레퍼런스

```java
   public static void main(String[] args) {
      List<LocalDate> dates = new ArrayList<>();
      dates.add(LocalDate.of(1993, 9, 27));
      dates.add(LocalDate.of(1993, 9, 3));
      dates.add(LocalDate.of(2022, 6, 28));

      dates.stream().map(Person::new).collect(Collectors.toList());
   }
```
메서드 레퍼런스는 메서드 호출을 한번하는 람다를 간추리는 것이기 때문에

위와같이 생성자를 레퍼런스 할 수 있다.

```java
   public Person() {

   }

   public Person(LocalDate birthday) {
      this.birthday = birthday;
   }
```
만약 생성자가 2개가 있을 때 인자가 없는 생성자를 사용하고 싶으면 어떻게 해야할까?

함수형 인터페이스를 살펴보면서 알아보자.

### 함수형 인터페이스




